# G233 SoC 硬件手册（教学版）

!!! warning "免责声明"
    本手册描述的是用于 QEMU 训练营的 **教学用虚拟 SoC/板卡（G233）** 的规格与编程模型，并不对应任何实体芯片。
    训练营可能在不另行通知的情况下调整实现细节；若手册与实际实现不一致，以测题/参考实现为准。

!!! note "主要贡献者"
    - 维护：[@zevorn](https://github.com/zevorn)

| 项目 | 值 |
| --- | --- |
| 目标读者 | 训练营学员、平台建模/驱动开发人员 |
| 适用范围 | `docs/exercise/2026/stage1/soc/`（SoC 方向） |
| 文档状态 | Draft |
| 最后更新 | 2026-01-30 |

## 1. 概述

G233 是为 QEMU 训练营定制的虚拟 SoC/板卡。其设计目标是提供一个**足够小但覆盖关键子系统**的硬件抽象，用于：

- 板级/SoC 设备建模（MMIO、IRQ、总线、设备实例化与连接）
- 自定义指令扩展（RISC-V 指令译码、TCG 翻译、helper、异常处理）
- SPI 外设建模与存储器件互联（SSI、Flash、片选、中断）

本手册重点描述 **内存映射、外设寄存器、以及自定义指令的架构语义**。

## 2. 文档约定

### 2.1 数值与端序

- 除非特别说明，所有数值均为十六进制，形如 `0x1001_8000`（下划线仅用于分组）。
- 地址均为 **字节地址（byte addressable）**。
- 所有多字节寄存器访问均按 **小端序（little-endian）** 解释。

### 2.2 术语：未定义 / 实现定义

- **未定义（undefined）**：实现可以产生任意结果（包括但不限于异常/死循环/数据破坏）；软件不得依赖其行为。
- **实现定义（implementation-defined）**：实现必须在某处（手册或实现文档）给出选择；若未给出，软件仍不得依赖。

本手册对一些非关键细节会采用“实现定义/未定义”以避免与训练营实现细节冲突。

## 3. 系统架构

### 3.1 顶层框图（示意）

```text
+------------------------------------------------------------------------------+
|                       G233 Board Architecture Diagram                        |
|                                                                              |
|  +-----------------+       +--------------------+       +-----------------+  |
|  |       DRAM      | <---> |   riscv.g233.cpu   | <---> |       MROM      |  |
|  |   0x8000_0000   |       | - RVA23            |       |   0x0000_1000   |  |
|  |   0xBFFF_FFFF   |       | - Other Extensions |       |   0x0000_2FFF   |  |
|  +-----------------+       +----------+---------+       +-----------------+  |
|                                       |                                      |
|                   +-------------------+-------------------+                  |
|                   |                   |                   |                  |
|           +-------v-------+   +-------v-------+   +-------v-------+          |
|           |      PLIC     |   |     ACLINT    |   |     PL011     |          |
|           |  0x0C00_0000  |   |  0x0200_0000  |   |  0x1000_0000  |          |
|           |  0x0FFF_FFFF  |   |  0x0200_BFFF  |   |  0x1000_0FFF  |          |
|           +--------+------+   +--------+------+   +---------------+          |
|                    |                   |                                     |
|           +--------v------+   +--------v------+   +---------------+          |
|           |      GPIO     |   |      PWM      |   |      SPI      |          |
|           |  0x1001_2000  |   |  0x1001_5000  |   |  0x1001_8000  |          |
|           |  0x1001_20FF  |   |  0x1001_5FFF  |   |  0x1001_8FFF  |          |
|           +---------------+   +---------------+   +---------------+          |
|                                                                              |
|                              Bus Fabric / AXI/LIB                            |
|                                                                              |
+------------------------------------------------------------------------------+
```

!!! note
    图中 SPI 区域为训练营扩展外设；若你的实验阶段未启用 SPI，可忽略该模块。

## 4. 地址空间与存储器映射

### 4.1 地址映射总览

下表给出 G233 低地址空间（低 32 位）内的主要映射。未列出的地址范围为 **实现定义**（可能返回 0、产生总线错误或触发访存异常）。

| 区域 | Base | End | Size | 访问属性 | 说明 |
| --- | --- | --- | --- | --- | --- |
| MROM | `0x0000_1000` | `0x0000_2FFF` | 8 KiB | R-X | 启动只读存储区（Boot ROM） |
| ACLINT (MSWI) | `0x0200_0000` | `0x0200_3FFF` | 16 KiB | R/W | 软件中断（Machine SW Interrupt） |
| ACLINT (MTIME/MTIMECMP) | `0x0200_4000` | `0x0200_BFFF` | 32 KiB | R/W | 机器定时器（Machine Timer） |
| PLIC | `0x0C00_0000` | `0x0FFF_FFFF` | 64 MiB | R/W | 外部中断控制器（PLIC） |
| PL011 UART | `0x1000_0000` | `0x1000_0FFF` | 4 KiB | R/W | 串口控制器（PL011 兼容） |
| GPIO | `0x1001_2000` | `0x1001_20FF` | 256 B | R/W | 通用 GPIO |
| PWM | `0x1001_5000` | `0x1001_5FFF` | 4 KiB | R/W | PWM 控制器 |
| SPI（可选） | `0x1001_8000` | `0x1001_8FFF` | 4 KiB | R/W | SPI 控制器（见第 7 章） |
| DRAM | `0x8000_0000` | `0xBFFF_FFFF` | 1 GiB | R/W/X | 主内存 |

### 4.2 MMIO 访问规则（通用）

- 除非章节另行说明，MMIO 寄存器按 **32-bit** 对齐访问；非对齐访问的行为为 **实现定义**。
- 对寄存器中标记为 **保留（Reserved）** 的位：软件 **必须写 0**，读出值为 **实现定义**。
- 同一寄存器的并发访问、以及设备内部状态机的精确定序为 **实现定义**（建议驱动使用轮询/中断配合，并做好超时保护）。

## 5. 处理器与中断子系统

### 5.1 CPU 概览

- 处理器核名称：`riscv.g233.cpu`
- ISA：符合 RISC-V ISA RVA23（并包含训练营自定义扩展指令，见第 6 章）

!!! note
    本手册不枚举 RVA23 的全部扩展集合；如需精确 ISA/CSR 行为，以训练营给出的 QEMU 配置与实现为准。

### 5.2 启动与复位（概念模型）

- 复位后 CPU 从 MROM 区域取指执行（具体入口地址由平台配置/固件决定）。
- MROM 内容通常用于最小初始化并跳转到 DRAM 中的后续代码。

### 5.3 中断控制器

- **ACLINT**：提供软件中断（MSWI）与机器定时器（MTIME/MTIMECMP），用于 M-mode 的 `MSIP/MTIP` 等本地中断源。
- **PLIC**：聚合板级外设的外部中断源，并向 CPU 递交外部中断。

本手册仅定义 PLIC/ACLINT 的地址映射；中断源编号与优先级策略为 **平台集成定义**。

## 6. 自定义指令扩展

### 6.1 编码约定

G233 自定义指令采用 32-bit R-type 编码，并复用 `rd` 字段作为输入操作数（即：**这些指令不写回通用寄存器**）。

固定字段如下：

- `opcode = 0b1111011`（`0x7B`）
- `funct3 = 0b110`

各指令通过 `func7` 区分：

| 指令 | func7（二进制） | func7（十进制） |
| --- | --- | --- |
| `dma` | `0000110` | 6 |
| `sort` | `0010110` | 22 |
| `crush` | `0100110` | 38 |
| `expand` | `0110110` | 54 |

通用格式示意：

```c
31      25 24  20 19    15 14     12  11                7 6     0
+---------+--------+--------+----------+-------------------+-------+
|  func7  |  rs2   |  rs1   |  funct3  |         rd        | opcode|
+---------+--------+--------+----------+-------------------+-------+
```

!!! warning
    由于 `rd` 字段被复用为输入操作数，这些指令在汇编层面看起来仍是 `OP rd, rs1, rs2` 形态，但其“第一个操作数”并非写回目的寄存器。编写汇编/内联汇编时请特别注意。

### 6.2 `dma`：FP32 矩阵转置搬运

该指令将一个 FP32 精度二维矩阵从 `rs1` 指向的源地址读取，按转置后写入 `rd` 指向的目的地址。

#### 6.2.1 操作数

- `rs1`：源矩阵起始地址（byte address）
- `rd`：目的矩阵起始地址（byte address）
- `rs2`：矩阵规模 `grain`
    - `0`：`N = 8`
    - `1`：`N = 16`
    - `2`：`N = 32`

#### 6.2.2 语义（规范化描述）

- 若 `grain > 2`，触发 **Illegal Instruction** 异常。
- 令 `N = 1 << (grain + 3)`。
- 源矩阵与目的矩阵均按行主序（row-major）解释，元素为 32-bit（FP32 位宽）。

伪代码（以 32-bit load/store 表示）：

```c
if (grain > 2) trap_illegal_instruction();

N = 1U << (grain + 3);
for (i = 0; i < N; i++) {
    for (j = 0; j < N; j++) {
        tmp = load_u32(src + (i * N + j) * 4);
        store_u32(dst + (j * N + i) * 4, tmp);
    }
}
```

#### 6.2.3 约束与边界条件

- `src`/`dst` 对应的地址范围必须可读/可写，否则触发访存异常（具体异常类型由实现决定）。
- 建议 `src` 与 `dst` 4 字节对齐；未对齐访问的行为为实现定义（可能触发未对齐访存异常）。
- 若 `src` 与 `dst` 地址范围重叠，结果为 **未定义**（建议软件避免重叠）。

### 6.3 `sort`：INT32 冒泡排序（原地）

该指令对 `rs1` 指向的 INT32 数组进行冒泡排序，排序结果写回原数组。

#### 6.3.1 操作数

- `rs1`：数组起始地址（byte address）
- `rs2`：数组长度 `len`（元素个数）
- `rd`：参与排序的数量 `k`（元素个数）

#### 6.3.2 语义（规范化描述）

- 若 `k > len`，触发 **Illegal Instruction** 异常。
- 对范围 `[0, k)` 的元素执行升序排序；比较按 **有符号 32-bit 整数**。
- 排序为原地操作，不产生额外输出缓冲区。

参考伪代码：

```c
if (k > len) trap_illegal_instruction();

for (i = 0; i < k; i++) {
    for (j = 0; j + 1 < k - i; j++) {
        if ((int32_t)a[j] > (int32_t)a[j + 1]) {
            tmp = a[j];
            a[j] = a[j + 1];
            a[j + 1] = tmp;
        }
    }
}
```

#### 6.3.3 约束与边界条件

- 数组元素按 32-bit load/store 访问；对齐/越界/页故障行为与普通访存一致。
- 当 `k == 0` 或 `k == 1` 时不产生写回（无副作用）。

### 6.4 `crush`：4-bit 压缩打包（8-bit 输入 → 8-bit 输出）

该指令从 `rs1` 指向的 8-bit 数组中提取每个元素的低 4 bit，并将相邻两个 nibble 打包成一个 8-bit 输出，写入 `rd` 指向的目的数组。

#### 6.4.1 操作数

- `rs1`：源数组起始地址（byte address）
- `rs2`：源数组长度 `len`（元素个数，单位：byte）
- `rd`：目的数组起始地址（byte address）

#### 6.4.2 语义（规范化描述）

- 输出数组长度为 `ceil(len / 2)` 字节。
- 对于偶数索引 `2t` 与 `2t + 1`：
    - `out[t].lo = in[2t] & 0x0F`
    - `out[t].hi = in[2t + 1] & 0x0F`
- 若 `len` 为奇数，最后一个输出字节的高 4 bit 置 0。

参考伪代码：

```c
out_len = (len + 1) / 2;
for (t = 0; t < out_len; t++) {
    lo = in[2 * t] & 0x0F;
    hi = 0;
    if (2 * t + 1 < len) {
        hi = (in[2 * t + 1] & 0x0F) << 4;
    }
    out[t] = lo | hi;
}
```

#### 6.4.3 约束与边界条件

- 若源/目的地址范围重叠，结果为 **未定义**。

### 6.5 `expand`：4-bit 解包展开（8-bit 输入 → 8-bit 输出）

该指令将 `rs1` 指向的 8-bit 数组按 nibble 拆分：每个输入字节拆成两个输出字节（低 nibble 与高 nibble），写入 `rd` 指向的目的数组。

#### 6.5.1 操作数

- `rs1`：源数组起始地址（byte address）
- `rs2`：源数组长度 `len`（元素个数，单位：byte）
- `rd`：目的数组起始地址（byte address）

#### 6.5.2 语义（规范化描述）

- 输出数组长度为 `2 * len` 字节。
- 对每个输入字节 `in[i]`：
    - `out[2i] = in[i] & 0x0F`
    - `out[2i + 1] = (in[i] >> 4) & 0x0F`

参考伪代码：

```c
for (i = 0; i < len; i++) {
    out[2 * i] = in[i] & 0x0F;
    out[2 * i + 1] = (in[i] >> 4) & 0x0F;
}
```

#### 6.5.3 约束与边界条件

- 若源/目的地址范围重叠，结果为 **未定义**。

## 7. 扩展外设：SPI 控制器（可选）

SPI (Serial Peripheral Interface) 控制器提供全双工同步串行通信能力，可用于连接外部传感器、存储器件（Flash）等。

### 7.1 功能特性

- 主/从模式（通过寄存器选择，具体互联由平台决定）
- 全双工同步传输
- 8-bit 数据位宽
- 4 路片选信号（CS0~CS3）
- 中断：TXE、RXNE、错误（溢出/下溢）

### 7.2 寄存器映射

SPI 基地址见第 4 章（`0x1001_8000`）。下表为寄存器偏移（Offset = Base + Offset）。

| Offset | 寄存器 | 访问 | 复位值 | 描述 |
| --- | --- | --- | --- | --- |
| `0x00` | `SPI_CR1` | R/W | `0x0000_0000` | 控制寄存器 1 |
| `0x04` | `SPI_CR2` | R/W | `0x0000_0000` | 控制寄存器 2 |
| `0x08` | `SPI_SR` | R/W | `0x0000_0002` | 状态寄存器 |
| `0x0C` | `SPI_DR` | R/W | `0x0000_000C` | 数据寄存器 |
| `0x10` | `SPI_CSCTRL` | R/W | `0x0000_0000` | CS 控制寄存器 |

### 7.3 寄存器定义

#### 7.3.1 `SPI_CR1`（Offset `0x00`）— Control Register 1

| Bit | 名称 | 访问 | 复位 | 描述 |
| --- | --- | --- | --- | --- |
| `31:7` | Reserved | - | `0` | 保留位，必须保持为 0 |
| `6` | `SPE` | R/W | `0` | SPI 使能：`0` 禁用；`1` 使能 |
| `5:3` | Reserved | - | `0` | 保留位，必须保持为 0 |
| `2` | `MSTR` | R/W | `0` | 主从选择：`0` 从模式；`1` 主模式 |
| `1:0` | Reserved | - | `0` | 保留位，必须保持为 0 |

#### 7.3.2 `SPI_CR2`（Offset `0x04`）— Control Register 2

| Bit | 名称 | 访问 | 复位 | 描述 |
| --- | --- | --- | --- | --- |
| `31:8` | Reserved | - | `0` | 保留位，必须保持为 0 |
| `7` | `TXEIE` | R/W | `0` | TXE 中断使能：`0` 禁用；`1` 使能 |
| `6` | `RXNEIE` | R/W | `0` | RXNE 中断使能：`0` 禁用；`1` 使能 |
| `5` | `ERRIE` | R/W | `0` | 错误中断使能（溢出/下溢）：`0` 禁用；`1` 使能 |
| `4` | `SSOE` | R/W | `0` | 软件片选输出使能：`0` 禁用；`1` 使能 |
| `3:0` | Reserved | - | `0` | 保留位，必须保持为 0 |

#### 7.3.3 `SPI_SR`（Offset `0x08`）— Status Register

| Bit | 名称 | 访问 | 复位 | 描述 |
| --- | --- | --- | --- | --- |
| `31:8` | Reserved | R | `0` | 保留位 |
| `7` | `BSY` | R | `0` | 忙标志：`0` 空闲；`1` 忙 |
| `6:4` | Reserved | R | `0` | 保留位 |
| `3` | `OVERRUN` | R/W | `0` | 溢出错误：`1` 表示发生；写 1 清除 |
| `2` | `UNDERRUN` | R/W | `0` | 下溢错误：`1` 表示发生；写 1 清除 |
| `1` | `TXE` | R | `1` | 发送缓冲区空：`1` 空；`0` 满 |
| `0` | `RXNE` | R | `0` | 接收缓冲区非空：`1` 非空；`0` 为空 |

#### 7.3.4 `SPI_DR`（Offset `0x0C`）— Data Register

| Bit | 名称 | 访问 | 复位 | 描述 |
| --- | --- | --- | --- | --- |
| `31:8` | Reserved | - | `0` | 保留位，必须保持为 0 |
| `7:0` | `DATA` | R/W | `0x0C` | 写入：发送数据；读取：接收数据 |

#### 7.3.5 `SPI_CSCTRL`（Offset `0x10`）— Chip Select Control

| Bit | 名称 | 访问 | 复位 | 描述 |
| --- | --- | --- | --- | --- |
| `31:8` | Reserved | - | `0` | 保留位，必须保持为 0 |
| `7` | `CS3_ACT` | R/W | `0` | CS3 激活：`0` 未激活；`1` 激活 |
| `6` | `CS2_ACT` | R/W | `0` | CS2 激活：`0` 未激活；`1` 激活 |
| `5` | `CS1_ACT` | R/W | `0` | CS1 激活：`0` 未激活；`1` 激活 |
| `4` | `CS0_ACT` | R/W | `0` | CS0 激活：`0` 未激活；`1` 激活 |
| `3` | `CS3_EN` | R/W | `0` | CS3 使能：`0` 禁用；`1` 使能 |
| `2` | `CS2_EN` | R/W | `0` | CS2 使能：`0` 禁用；`1` 使能 |
| `1` | `CS1_EN` | R/W | `0` | CS1 使能：`0` 禁用；`1` 使能 |
| `0` | `CS0_EN` | R/W | `0` | CS0 使能：`0` 禁用；`1` 使能 |

### 7.4 编程模型（建议流程）

1. 初始化：配置 `SPI_CR1.MSTR`（主/从）与 `SPI_CR1.SPE`（使能），按需配置 `SPI_CR2` 中断位。
2. 片选：通过 `SPI_CSCTRL` 使能并激活目标 CS（CS 具体有效电平与互联时序为实现定义）。
3. 传输：
    - 轮询 `SPI_SR.TXE == 1` 后写 `SPI_DR.DATA` 发起发送；
    - 轮询 `SPI_SR.RXNE == 1` 后读 `SPI_DR.DATA` 获取接收数据。
4. 错误处理：若 `SPI_SR.OVERRUN/UNDERRUN == 1`，向 `SPI_SR` 对应位写 1 清除，并重新初始化传输状态。
5. 结束：取消激活 CS，必要时关闭 `SPI_CR1.SPE`。

## 8. 已知限制

- 自定义指令扩展复用了 `rd` 字段作为输入操作数；常规汇编器/反汇编器可能无法正确显示其“无写回”语义，必要时使用 `.insn` 或自定义汇编宏。
- 部分模块（例如中断源编号、未映射地址访问行为）为实现定义，编写驱动时请加入超时与健壮性检查。
